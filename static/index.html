<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Meeting Transcriber</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      .row { margin: 12px 0; }
      button { padding: 8px 12px; }
      pre { white-space: pre-wrap; background: #f5f5f7; padding: 12px; border-radius: 8px; }
      .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eef; margin-right: 6px; }
      .formatted { background: #fcfcfd; border: 1px solid #e6e6eb; border-radius: 8px; padding: 12px; }
      .turn { margin: 8px 0; }
      .turn .meta { color: #555; font-size: 12px; margin-bottom: 2px; }
      .turn .text { line-height: 1.5; }
      .speakers { background: #fbfbfe; border: 1px dashed #d9d9e3; padding: 12px; border-radius: 8px; }
      .speaker-row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
      .speaker-row input { padding: 6px 8px; }
      .actions { margin-top: 8px; }
      .ms { background: #f6f9ff; border: 1px solid #dbe7ff; padding: 12px; border-radius: 8px; }
      .muted { color: #666; }
      .summary { background: #fdfaf5; border: 1px solid #f0e6d6; border-radius: 8px; padding: 12px; }
      .speaker-badge { display: inline-block; background: #eef; border-radius: 999px; padding: 2px 10px; font-weight: 600; margin-right: 8px; }
      .ts { color: #666; font-size: 12px; }
      .audio-event { color: #7a7a7a; font-style: italic; }
    </style>
  </head>
  <body>
    <h1>Meeting Transcriber</h1>

    <div class="row">
      <input id="fileInput" type="file" accept="audio/*,video/*" />
      <button id="uploadBtn">Upload & Transcribe</button>
    </div>

    <div class="row">
      <button id="recordBtn">Start Recording</button>
      <button id="stopBtn" disabled>Stop</button>
      <span id="recStatus" class="pill">Idle</span>
    </div>

    <div class="row">
      <label><input type="checkbox" id="diarize" checked /> Diarize speakers</label>
      <label style="margin-left:16px;"><input type="checkbox" id="tagEvents" checked /> Tag audio events</label>
      <label style="margin-left:16px;">Language code: <input id="lang" placeholder="e.g. eng" /></label>
    </div>

    <div class="row">
      <audio id="preview" controls></audio>
    </div>

    <div class="row">
      <h3>Summary</h3>
      <div id="summary" class="formatted"></div>
    </div>

    <div class="row">
      <h3>Microsoft 365</h3>
      <div class="ms">
        <div id="msStatus" class="muted">Loading Microsoft configâ€¦</div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
          <button id="msSignIn">Sign in</button>
          <button id="msSignOut" disabled>Sign out</button>
          <button id="msLoadMeetings" disabled>Load my meetings</button>
          <select id="msEvents" disabled></select>
          <button id="msSaveNotes" disabled>Save notes to event</button>
        </div>
      </div>
    </div>

    <div class="row">
      <h3>Speakers</h3>
      <div id="speakers" class="speakers"></div>
    </div>

    <div class="row">
      <h3>Formatted transcript</h3>
      <div id="formatted" class="formatted"></div>
    </div>

    <div class="row">
      <h3>Transcript</h3>
      <pre id="output"></pre>
    </div>

    <div class="row">
      <h3>Text only</h3>
      <pre id="textOnly"></pre>
    </div>

    <script>
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const recordBtn = document.getElementById('recordBtn');
      const stopBtn = document.getElementById('stopBtn');
      const recStatus = document.getElementById('recStatus');
      const preview = document.getElementById('preview');
      const output = document.getElementById('output');
      const diarize = document.getElementById('diarize');
      const tagEvents = document.getElementById('tagEvents');
      const lang = document.getElementById('lang');
      const formatted = document.getElementById('formatted');
      const textOnly = document.getElementById('textOnly');
      const speakersEl = document.getElementById('speakers');
      const summaryEl = document.getElementById('summary');
      const msStatus = document.getElementById('msStatus');
      const msSignIn = document.getElementById('msSignIn');
      const msSignOut = document.getElementById('msSignOut');
      const msLoadMeetings = document.getElementById('msLoadMeetings');
      const msEvents = document.getElementById('msEvents');
      const msSaveNotes = document.getElementById('msSaveNotes');

      let mediaRecorder;
      let chunks = [];
      let lastResult = null;
      let msalApp = null;
      let msAccount = null;
      let msConfig = null;

      function setStatus(text) { recStatus.textContent = text; }
      function print(obj) { output.textContent = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2); }

      function formatTs(sec) {
        if (sec == null || isNaN(sec)) return '';
        const s = Math.max(0, Number(sec));
        const m = Math.floor(s / 60);
        const r = s - m * 60;
        const ss = String(Math.floor(r)).padStart(2, '0');
        const ms = String(Math.round((r - Math.floor(r)) * 1000)).padStart(3, '0');
        return `${m}:${ss}.${ms}`;
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }

      function renderSummaryMarkdownInto(el, rawText) {
        const safe = escapeHtml(rawText || '');
        const lines = safe.split(/\n+/);
        let html = '';
        let inList = false;
        for (const raw of lines) {
          const line = raw.trim();
          if (line.startsWith('### ')) { if (inList) { html += '</ul>'; inList = false; } html += `<h3>${line.slice(4)}</h3>`; continue; }
          if (line.startsWith('## '))  { if (inList) { html += '</ul>'; inList = false; } html += `<h2>${line.slice(3)}</h2>`; continue; }
          if (line.startsWith('- '))   { if (!inList) { html += '<ul>'; inList = true; } html += `<li>${line.slice(2).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')}</li>`; continue; }
          if (!line) { if (inList) { html += '</ul>'; inList = false; } continue; }
          html += `<p>${line.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')}</p>`;
        }
        if (inList) html += '</ul>';
        el.innerHTML = `<div class="summary">${html}</div>`;
      }

      function formatLocalDateTime(isoLike) {
        try {
          if (!isoLike) return '';
          const d = new Date(isoLike);
          // Fallback if parse fails
          if (isNaN(d.getTime())) return String(isoLike);
          return d.toLocaleString(undefined, {
            year: 'numeric', month: 'short', day: '2-digit',
            hour: '2-digit', minute: '2-digit'
          });
        } catch (_) {
          return String(isoLike);
        }
      }

      function parseGraphDateTime(dateTime, timeZone) {
        if (!dateTime) return null;
        // If Graph says the value is in UTC but the string lacks 'Z', coerce to UTC
        const isUtc = (timeZone || '').toUpperCase() === 'UTC' || /Z$/.test(dateTime);
        const iso = isUtc && !/Z$/.test(dateTime) ? `${dateTime}Z` : dateTime;
        const d = new Date(iso);
        return isNaN(d.getTime()) ? null : d;
      }

      function loadNameMap() {
        try { return JSON.parse(localStorage.getItem('speakerNameMap') || '{}'); } catch (_) { return {}; }
      }

      function saveNameMap(map) {
        localStorage.setItem('speakerNameMap', JSON.stringify(map || {}));
      }

      function buildFormatted(result, nameMap) {
        try {
          const words = Array.isArray(result?.words) ? result.words : [];
          if (!words.length) return '<div class="turn"><div class="text">No words returned.</div></div>';

          const turns = [];
          let current = { speaker: words[0].speaker_id || 'speaker_0', start: null, end: null, text: '' };

          for (const w of words) {
            const speaker = w.speaker_id || current.speaker;
            const isNewSpeaker = speaker !== current.speaker;
            if (isNewSpeaker) {
              turns.push(current);
              current = { speaker, start: null, end: null, text: '' };
            }
            if (w.start != null) current.start = current.start == null ? w.start : Math.min(current.start, w.start);
            if (w.end != null) current.end = current.end == null ? w.end : Math.max(current.end, w.end);
            if (w.type === 'spacing') {
              current.text += ' ';
            } else if (w.type === 'audio_event') {
              current.text += ` (${w.text})`;
            } else {
              current.text += w.text;
            }
          }
          turns.push(current);

          return turns.map(t => {
            const display = nameMap?.[t.speaker] ? `${nameMap[t.speaker]} (${t.speaker})` : t.speaker;
            const meta = `${escapeHtml(display)}  [${formatTs(t.start)} - ${formatTs(t.end)}]`;
            const text = escapeHtml(t.text).replace(/\s+/g, ' ').trim();
            return `<div class="turn"><div class="meta">${meta}</div><div class="text">${text}</div></div>`;
          }).join('');
        } catch (e) {
          return `<div class="turn"><div class="text">Failed to format transcript.</div></div>`;
        }
      }

      // ---------- Microsoft Graph integration (optional) ----------
      async function loadMsConfig() {
        try {
          const res = await fetch('/config/ms');
          msConfig = await res.json();
          if (!msConfig?.enabled) {
            msStatus.textContent = 'Microsoft integration is not configured. Set MS_CLIENT_ID (and optional MS_TENANT_ID, MS_REDIRECT_URI) in .env.';
            disableMsUI(true);
            return;
          }
          // Load MSAL script dynamically
          await loadScript('https://alcdn.msauth.net/browser/2.38.0/js/msal-browser.min.js');
          const config = {
            auth: {
              clientId: msConfig.clientId,
              authority: msConfig.authority,
              redirectUri: msConfig.redirectUri,
            },
            cache: { cacheLocation: 'localStorage', storeAuthStateInCookie: false },
          };
          // eslint-disable-next-line no-undef
          msalApp = new msal.PublicClientApplication(config);
          const accounts = msalApp.getAllAccounts();
          if (accounts && accounts.length) {
            msAccount = accounts[0];
            msalApp.setActiveAccount(msAccount);
            msStatus.textContent = `Signed in as ${msAccount.username}`;
            disableMsUI(false);
          } else {
            msStatus.textContent = 'Not signed in';
            disableMsUI(true);
          }
        } catch (e) {
          msStatus.textContent = 'Failed to initialize Microsoft integration.';
          disableMsUI(true);
        }
      }

      function disableMsUI(disabled) {
        msSignIn.disabled = !msConfig?.enabled ? true : false;
        msSignOut.disabled = disabled;
        msLoadMeetings.disabled = disabled;
        msEvents.disabled = disabled;
        msSaveNotes.disabled = disabled;
      }

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src; s.async = true; s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
        });
      }

      async function ensureToken(scopes) {
        if (!msalApp) throw new Error('MSAL not initialized');
        const request = { scopes, account: msalApp.getActiveAccount() };
        try {
          const r = await msalApp.acquireTokenSilent(request);
          return r.accessToken;
        } catch (_) {
          const r = await msalApp.acquireTokenPopup({ scopes });
          return r.accessToken;
        }
      }

      async function listMeetings() {
        try {
          const token = await ensureToken(msConfig.scopes);
          const now = new Date();
          const start = new Date(now.getTime() - 24*60*60*1000).toISOString(); // 1 day back
          const end = new Date(now.getTime() + 30*24*60*60*1000).toISOString(); // 30 days forward
          const url = `https://graph.microsoft.com/v1.0/me/calendarView?startDateTime=${encodeURIComponent(start)}&endDateTime=${encodeURIComponent(end)}&$top=50&$orderby=start/dateTime&$select=id,subject,start,end,organizer`;
          const res = await fetch(url, { headers: { Authorization: `Bearer ${token}` } });
          const j = await res.json();
          const events = Array.isArray(j.value) ? j.value : [];
          msEvents.innerHTML = events.map(ev => {
            const subj = ev.subject || '(no subject)';
            const startDt = ev.start?.dateTime || '';
            const tz = ev.start?.timeZone || '';
            const d = parseGraphDateTime(startDt, tz);
            const pretty = d ? d.toLocaleString(undefined, { year:'numeric', month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' }) : startDt;
            return `<option value="${ev.id}">${escapeHtml(subj)} â€” ${escapeHtml(pretty)}</option>`;
          }).join('');
          if (events.length) msEvents.value = events[0].id;
          msStatus.textContent = `Loaded ${events.length} events`;
        } catch (e) {
          msStatus.textContent = 'Failed to load meetings.';
        }
      }

      function buildHtmlNotes() {
        const map = loadNameMap();
        const formattedHtml = buildFormatted(lastResult || {}, map);
        const summaryText = summaryEl.innerText || '';
        return [
          '<div><h2>Meeting notes (Transcriber)</h2>',
          `<h3>AI Summary</h3><p>${escapeHtml(summaryText).replace(/\n/g, '<br/>')}</p>`,
          '<h3>Transcript</h3>',
          formattedHtml,
          '</div>'
        ].join('');
      }

      async function saveNotesToEvent() {
        if (!lastResult) { alert('Transcribe first'); return; }
        const eventId = msEvents.value;
        if (!eventId) { alert('Pick an event'); return; }
        try {
          const token = await ensureToken(['Calendars.ReadWrite']);
          // Get existing body
          const getRes = await fetch(`https://graph.microsoft.com/v1.0/me/events/${eventId}?$select=body`, {
            headers: { Authorization: `Bearer ${token}` }
          });
          const event = await getRes.json();
          const existing = event?.body?.content || '';
          const notes = buildHtmlNotes();
          const merged = existing ? existing + '<hr/>' + notes : notes;
          const patchRes = await fetch(`https://graph.microsoft.com/v1.0/me/events/${eventId}`, {
            method: 'PATCH',
            headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ body: { contentType: 'html', content: merged } })
          });
          if (!patchRes.ok) throw new Error('PATCH failed');
          msStatus.textContent = 'Notes saved to event.';
        } catch (e) {
          msStatus.textContent = 'Failed to save notes.';
        }
      }

      msSignIn.addEventListener('click', async () => {
        if (!msalApp) return;
        try {
          const login = await msalApp.loginPopup({ scopes: msConfig.scopes });
          msAccount = login.account;
          msalApp.setActiveAccount(msAccount);
          msStatus.textContent = `Signed in as ${msAccount.username}`;
          disableMsUI(false);
        } catch (_) { /* ignore */ }
      });

      msSignOut.addEventListener('click', async () => {
        if (!msalApp) return;
        try { await msalApp.logoutPopup(); } catch (_) {}
        msAccount = null;
        msStatus.textContent = 'Signed out';
        disableMsUI(true);
      });

      msLoadMeetings.addEventListener('click', listMeetings);
      msSaveNotes.addEventListener('click', saveNotesToEvent);

      // Init MSAL config on load
      loadMsConfig();

      function buildSummary(result, nameMap) {
        const text = result?.text || '';
        const words = Array.isArray(result?.words) ? result.words : [];
        const speakers = uniqueSpeakers(result);
        const names = speakers.map(id => nameMap?.[id] || id);
        let duration = '';
        if (words.length) {
          const first = words.find(w => w.start != null);
          const last = [...words].reverse().find(w => w.end != null);
          if (first && last) {
            duration = `${formatTs(first.start)} - ${formatTs(last.end)} (${(last.end - first.start).toFixed(1)}s)`;
          }
        }
        const sentences = text.split(/(?<=[.!?])\s+/).filter(Boolean);
        let summaryText = text;
        if (sentences.length > 2) summaryText = sentences.slice(0, 2).join(' ');
        if (summaryText.length > 400) summaryText = summaryText.slice(0, 397) + '...';
        const meta = `Speakers: ${escapeHtml(names.join(', '))}${duration ? ' â€¢ Duration: ' + escapeHtml(duration) : ''}`;
        return `<div class="meta">${meta}</div><div class="text">${escapeHtml(summaryText)}</div>`;
      }

      function uniqueSpeakers(result) {
        const set = new Set();
        const words = Array.isArray(result?.words) ? result.words : [];
        for (const w of words) {
          if (w.speaker_id) set.add(w.speaker_id);
        }
        return Array.from(set);
      }

      function renderSpeakers(result) {
        const ids = uniqueSpeakers(result);
        const nameMap = loadNameMap();
        if (!ids.length) { speakersEl.innerHTML = '<div>No speakers detected.</div>'; return; }
        const rows = ids.map(id => {
          const val = '';
          return `<div class="speaker-row"><label style="min-width:110px;">${escapeHtml(id)}</label><input data-speaker-id="${escapeHtml(id)}" type="text" placeholder="Enter name" value="${escapeHtml(val)}" /></div>`;
        }).join('');
        speakersEl.innerHTML = rows + '<div class="actions"><button id="applyNames">Apply names</button><button id="summarizeBtn" style="margin-left:8px;">Summarize</button></div>';
        // Wire inputs
        speakersEl.querySelectorAll('input[data-speaker-id]').forEach(input => {
          input.addEventListener('input', () => {
            const id = input.getAttribute('data-speaker-id');
            const map = loadNameMap();
            map[id] = input.value;
            saveNameMap(map);
          });
        });
        const applyBtn = document.getElementById('applyNames');
        if (applyBtn) {
          applyBtn.addEventListener('click', () => {
            if (!lastResult) return;
            const map = loadNameMap();
            formatted.innerHTML = buildFormatted(lastResult, map);
            summaryEl.innerHTML = buildSummary(lastResult, map);
          });
        }

        const summarizeBtn = document.getElementById('summarizeBtn');
        if (summarizeBtn) {
          summarizeBtn.addEventListener('click', async () => {
            if (!lastResult) return;
            const map = loadNameMap();
            try {
              const res2 = await fetch('/api/summarize', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  text: lastResult?.text || '',
                  words: lastResult?.words || [],
                  language_code: lastResult?.language_code,
                  speaker_names: map,
                }),
              });
              if (res2.ok) {
                const j2 = await res2.json();
                if (j2?.summary_text) {
                  renderSummaryMarkdownInto(summaryEl, j2.summary_text);
                  return;
                }
              }
              summaryEl.innerHTML = buildSummary(lastResult, map);
            } catch (_) {
              summaryEl.innerHTML = buildSummary(lastResult, map);
            }
          });
        }
      }

      async function transcribeBlob(blob) {
        const form = new FormData();
        form.append('file', blob, 'recording.webm');
        form.append('diarize', String(diarize.checked));
        form.append('tag_audio_events', String(tagEvents.checked));
        if (lang.value.trim()) form.append('language_code', lang.value.trim());
        // Clear previous speaker-name map so new run starts blank
        try { localStorage.removeItem('speakerNameMap'); } catch (_) {}

        const res = await fetch('/api/transcribe', { method: 'POST', body: form });
        if (!res.ok) {
          const err = await res.json().catch(() => ({ detail: res.statusText }));
          throw new Error(err.detail || 'Transcription failed');
        }
        const json = await res.json();
        lastResult = json;
        renderSpeakers(json);
        const map = loadNameMap();
        formatted.innerHTML = buildFormatted(json, map);
        summaryEl.innerHTML = buildSummary(json, map);
        textOnly.textContent = json?.text || '';

        // Try Azure summary if configured
        try {
          const res2 = await fetch('/api/summarize', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              text: json?.text || '',
              words: json?.words || [],
              language_code: json?.language_code,
              speaker_names: map,
            }),
          });
          if (res2.ok) {
            const j2 = await res2.json();
            if (j2?.summary_text) {
              // Render lightweight markdown for headings/bullets/bold
              try {
                const safe = escapeHtml(j2.summary_text);
                const lines = safe.split(/\n+/);
                let html = '';
                let inList = false;
                for (const raw of lines) {
                  const line = raw.trim();
                  if (line.startsWith('### ')) { if (inList) { html += '</ul>'; inList = false; } html += `<h3>${line.slice(4)}</h3>`; continue; }
                  if (line.startsWith('## '))  { if (inList) { html += '</ul>'; inList = false; } html += `<h2>${line.slice(3)}</h2>`; continue; }
                  if (line.startsWith('- '))   { if (!inList) { html += '<ul>'; inList = true; } html += `<li>${line.slice(2).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')}</li>`; continue; }
                  if (!line) { if (inList) { html += '</ul>'; inList = false; } continue; }
                  html += `<p>${line.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')}</p>`;
                }
                if (inList) html += '</ul>';
                summaryEl.innerHTML = `<div class="summary">${html}</div>`;
              } catch (_) {
                summaryEl.innerHTML = `<div class="text">${safe}</div>`;
              }
            }
          }
        } catch (e) { /* ignore */ }

        return json;
      }

      uploadBtn.addEventListener('click', async () => {
        try {
          if (!fileInput.files.length) return alert('Choose a file first');
          setStatus('Uploading...');
          const file = fileInput.files[0];
          preview.src = URL.createObjectURL(file);
          const result = await transcribeBlob(file);
          print(result);
          setStatus('Done');
        } catch (e) {
          print({ error: e.message });
          setStatus('Error');
        }
      });

      recordBtn.addEventListener('click', async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          chunks = [];
          mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
          mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            preview.src = URL.createObjectURL(blob);
            setStatus('Transcribing...');
            try {
              const result = await transcribeBlob(blob);
              print(result);
              setStatus('Done');
            } catch (e) {
              print({ error: e.message });
              setStatus('Error');
            }
          };
          mediaRecorder.start();
          recordBtn.disabled = true;
          stopBtn.disabled = false;
          setStatus('Recording...');
        } catch (e) {
          alert('Mic permission denied or unavailable');
        }
      });

      stopBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          recordBtn.disabled = false;
          stopBtn.disabled = true;
        }
      });
    </script>
  </body>
  </html>


